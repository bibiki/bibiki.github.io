---
layout: post
title: Command Line Minesweeper
---
<span style="color: red">I first posted this on [Medium](https://medium.com/@ngadhnjim/command-line-minesweeper-832402069d57), now I am posting it here, too.</span>

Playing Minesweeper via the command line is not the most practical way to play it. Especially not in a non-interactive way. However, I have implemented a Minesweeper game as a command line application and it was pretty fun. Let me show how here.

If you chose to follow this post, you will have been introduced to the picocli framework for rapid development of command line utilities with Java. In addition to that, you will get some hands-on experience writing actual code in the process of implementing the Minesweeper game. Take this for a small tutorial developing a Java application.

Let us list the commands that our application needs to be able to understand:

1. new - to start a new game
2. show - to show the current state of the grid
3. opentile $row $col - to open tile position on row $row and column $col

Now that we know the commands we need to implement, let us quickly start a maven project, include picocli as a dependency to our project, and write empty methods for our commands. This way we will have everything in place required of a command line utility. The actual functionality that the commands will implement will be added after that is out of the way.

## To start a maven project...

...go to your Eclipse, select File > New > Maven Project. In the wizard that pops up, you need to make sure that Location is your Eclipse instance's workspace. For me that is /home/username/eclipse-workspace. After that, click next and in the new wizard you will see a Filter field. Fill it out with 'maven-archetype-quickstart'. This will filter the archetypes in the table below the field Filter. One of the remaining archetypes will have org.apache.maven.archetypes for group id. Select that, and click next. In the new wizard, you need to select a group id, an artefact id, and a package for your project. For group id, you may chose com.minesweeper. It is a convention to name packages like web domains, but in reverse. Next, specify Minesweeper for your artifact id. Specifying these two fields will result in package being filled automatically by Eclipse. I prefer to have my  group id and package the same, so if they differ for you at this point, you may modify the package field to make sure that it matches the group id. At this point, you may click finish to have your project generated. Pay attention to the console pane in your Eclipse as it may prompt you for some feedback. The defaults it suggests work pretty fine, so just click anywhere in the Console pane and press enter.

Now that your project has been initiated, you will find inside the root directory of your project a pom.xml file. Somewhere inside it, you will see these two lines:

```
	<properties>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		<maven.compiler.source>1.7</maven.compiler.source>
		<maven.compiler.target>1.7</maven.compiler.target>
	</properties>
```

That is indicating that your project's source code is Java 1.7 compliant. We would like to change that, to use a more recent version of Java. I opted to use 17 as that is pretty recent at this points. So here is how those liness should look so that you may smoothly follow this tutorial.

```
	<properties>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		<maven.compiler.source>17</maven.compiler.source>
		<maven.compiler.target>17</maven.compiler.target>
	</properties>
```

After this change, you may need to right click on the root directory of your project in Eclipse and then select Maven > Update Project.

Your pom will also have a ```<dependencies>``` section. Let us modify that section to have picocli included as a dependency to our project. I am pasting here only that section of pom.xml so you may copy it and replace that section in your pom.xml, without removing its other sections.

```
        <dependencies>
		<!-- https://mvnrepository.com/artifact/info.picocli/picocli -->
		<dependency>
			<groupId>info.picocli</groupId>
			<artifactId>picocli</artifactId>
			<version>4.7.5</version>
		</dependency>
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.11</version>
			<scope>test</scope>
		</dependency>
	</dependencies>
```

So, we have our dependencies in place. Picocli supports more than one pattern to layout command line applications. For this small Minesweeper game, I chose to have everything in a single file. Everything we write from now on out we will write inside our App.java file. Here is its state as generated by maven.

```
package com.minesweeper;

/**
 * Hello world!
 *
 */
public class App {
	public static void main(String[] args) {
		System.out.println("Hello World!");
	}
}
```

Let us change App.java to look like this.

```
package com.minesweeper;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import picocli.CommandLine.Command;
import picocli.CommandLine.Parameters;
import picocli.CommandLine;

@Command
public class App {

	@Command(name = "new")
	public void newGame() {
		
	}
	
	public static void main(String[] args) {
		new CommandLine(new App()).execute(args);
	}
}

```

*Because missing import statements are sometimes sources of confusion, I included here all the imports that will be used by the time this application is developed although some of them at this point are unecessary.*

Here is a quick explanation of everything that changed inside our App.java. We imported the CommandLine and Command classes so that we can use them inside our App.java file. Next, we annotated  our class with @Command. It is a requirement by picocli framework to annotated the class that will be passed in to CommandLine() with @Command. Similarly, new CommandLine() expects that its argument has at least one command method and so I added the new() method, since we will need it anyways. The method, too, is annotated with @Command and @Command's name attribute is set to new. This way, we will be able to use 'new' to tell our command line application that we want the newGame() method run for us. Finally, the main method contains what all picocli-based command line applications do. Since we have already determined that our application needs a show and an opentile command, we may immediately add those two commands now. Here is the new state of App.java.

```
package com.minesweeper;

import picocli.CommandLine;
import picocli.CommandLine.Command;

@Command
public class App {

	@Command(name = "new")
	public void newGame() {
		
	}
	
	@Command(name = "show")
	public void show() {
		
	}
	
	@Command(name = "opentile")
	public void opentile() {
		
	}
	
	public static void main(String[] args) {
		new CommandLine(new App()).execute(args);
	}
}
```

And that is pretty much everything we need for the command-line nature of our game. Everything that we write from now on out, is specific to the application being a Minesweeper game.

*Note that I will no longer paste App.java in entirety. Rather, I will list methods one by one and you may copy paste them inside App.java if you are following this tutorial.*

## Game Requirements

We will need to somehow discern between open tiles and closed tiles. Once a tile is open, it will be either an empty tile, a number indicating the number of adjacent tiles that are mines, or an actual mine. We will use M to signify a mine, a ' ' to signify an empty tile, and numbers to indicate the number of mines immediately next to the tile holding the number. Letter H will be used to signify a tile that has not be opened yet.

Our grid will have 20 rows and 50 columns, amounting to 1000 tiles. Of the 1000 tiles, 100 will mines scattered around the grid randomly.

## Starting the Implementation

Because our game is non-interactive, we will keep state of our game in a file. Hence, we will need a method to write to files. Also, there are two parts to the state of our game: 1. what the user sees, and 2. the actual grid with mines scattered around it. Also, we will store both of these parts of the state to the same file, one line for each. The first line will represent the grid with mine locations, but colapsed into one line. The second line will represent what the user sees for when viewing the grid; that is, the grid with mine locations not showing. When we write the first line of the game state, we want to overwrite whatever is in the file. However, when we write the second line to this file we want to append to the file so as not to overwrite the first line in the file. That means that the method that will write to the file will take an argument to specify what content to write to the file, and another boolean argument to tell it whether we want to overwrite the file content or append to it. Here is its implementation.

```
	private void writeLineInFile(String game, boolean append) throws IOException {
		Path fileName = Path.of("game.txt");
		if(append) {
			Files.writeString(fileName, game, StandardOpenOption.APPEND);
		}
		else {
			Files.writeString(fileName, game);
		}
	}
```

Remember, you may copy and paste this method inside your App.java file.

Next, we'd like to be able to retrieve the state of the game from the file. We would like to be able to retrieve either the grid with locations of mines specified or the state of the grid as the user sees it. So, sometimes we want to read the first line in the file and sometimes we want to read the second line in the file. Here is the implementation of two methods, one for each of the two purposes specified:

```
	private String getUserPesrpectiveFromFile() throws IOException {
		Path path = Paths.get("game.txt");
		String game = Files.readAllLines(path).get(1);
		return game;	
	}
	
	private String getGameFromFile() throws IOException {
		Path path = Paths.get("game.txt");
		String game = Files.readAllLines(path).get(0);
		return game;
	}
```

Let us now specify with comments inside our newGame() method all that that methods needs to do when a user decides they want to start a new game. Here is the newGame() method with comments for all of its constituent steps specified:

```
	@Command(name = "new")
	public void newGame() {
		//setup a random layout of mines in a grid of 1000 tiles
		//put the mines in a grid so that we can count the number of mines next to each tile
		//count the number of mines next to each tile
		//put the grid into one line as it is supposed to be when stored in our state file
		//initiate in one line the state as user sees it when looking at the grid
		//write the game state in the file
	}
```

Let us now implement a method that generates a random layout of 100 mines in a grid of 1000 tiles. Here is the method first, and a brief explanation of how it does its job following immediately after:

```
	private List<Integer> setUpMines() {
		List<Integer> numbers = IntStream.range(0, 1000).boxed().collect(Collectors.toList());
		Collections.shuffle(numbers);
		return numbers.subList(0, 100);
	}
```

So, although we show a grid, we can make use of a simple list instead when we are generating our random layout of 100 mines. So, we start with a list containing numbers from 0 to 999 and shuffle that list. We then take the first 100 of those numbers to stand for tiles in our grid that need to have a mines underneath them. For example, if one of the first 100 numbers selected in this step is 65, then it means that the second row contains a mine on its sixteenth columnd, as each of our rows will have 50 mines.

Next, we'd like to put our mines in our grid. Here, again, is the code for a method that does just that, followed by an explanation of the idea behind its implementation:

```
	private String[][] setUpGrid(List<Integer> mines) {
		String[][] grid = new String[20][50];
		for (Integer mine : mines) {
			int row = mine / 50;
			int col = mine % 50;
			grid[row][col] = "M";
		}
		
		for(int row = 0; row < grid.length; row++) {
			for(int col = 0; col < grid[0].length; col++) {
				if (grid[row][col] == null) grid[row][col] = " ";
			}
		}
		return grid;
	}
```

So, we initiate a grid of 20 rows and 50 columns and then, in the first for loop, we iterate over our mines. For each number that a mines is represented by we calculate its position just as we did for 65 determening that it is supposed to lay on tile column 14, in the second row. The next for-loop will put empty space in the rest of the tiles. The next step will count the number of mines adjacent to each tile that does not cover a mine.

Let us now implement a method to count how many mines each tile has next to it. Here is the code:

```
    private void setUpMineCounts(String[][] grid) {
        int north, east, south, west, northeast, southeast, southwest, northwest = 0;
        for (int row = 0; row < grid.length; row++) {
	    for (int col = 0; col < grid[0].length; col++) {
                if (grid[row][col].equals("M"))
                    continue;

                west = 0;
                if (col > 0 && grid[row][col-1].equals("M"))
                    west = 1;
                east = 0;
                if (col < grid[0].length - 1 && grid[row][col+1].equals("M"))
                    east = 1;
                north = 0;
                if ((row > 0) && grid[row - 1][col].equals("M"))
                    north = 1;
                south = 0;
                if (row < grid.length - 1 && grid[row + 1][col].equals("M"))
                    south = 1;
                northeast = 0;
                if (row > 0 && col < grid[0].length - 1 && grid[row - 1][col + 1].equals("M"))
                    northeast = 1;
                southeast = 0;
                if (row < grid.length - 1 && col < grid[0].length - 1 && grid[row + 1][col + 1].equals("M"))
                    southeast = 1;
                southwest = 0;
                if (row < grid.length - 1 && col > 0 && grid[row + 1][col - 1].equals("M"))
                    southwest = 1;
                northwest = 0;
                if (row > 0 && col > 0 && grid[row - 1][col - 1].equals("M"))
                    northwest = 1;
                int count = north + east + south + west + northeast + southeast + southwest + northwest;
                if(count > 0) grid[row][col] = String.valueOf(count);
            }
        }
    }
```

The method is pretty long, but it is just a tedious repetition of two lines, in a sense. Basically, a tile has eight neighbors, one in each of: north, sourth, east, west, northeast, northwest, southeast, and southwest directions. If a tiles is itself a mine, we do not want to replace it with the number of tiles adjacent to it that cover mines. If a tile is not a mine, we want to count how many mines it has for neighbors. If it has no mines next to it, we do not want to show 0 optiong instead to show an empty space (the last if statement in the method).

Now that we have the grid along with the count of mines next to each tile, we want to colapse the grid into one line so that we can store it in our file that contains the state of the game. Here is a method for that:

```
	private String putInOneLine(String[][] grid) {
		String result = "";
		for (String[] row : grid) {
			for (String col : row) {
				result = result + col + ",";
			}
		}
		return result+"\n";
	}
```

All this method does is take a two-dimensional array of strings and concatenate them one after the other into a single string, which conforms to our plan for storing game state in a file.


Next, we want to initiate a string that shows the user perspective on the game, with mines covered by tiles. Remember that we are currently implementing helper methods for our newGame() method, meaning that at this point what the user sees is 1000 tiles in a 20 by 50 grid. Our state, however, sees that as a single string of 1000 comma-separated Hs, as we use H to signify a tile that has not been flipped over yet. Here is the code for that method:

```
	private String initUserPerspective() {
		return "H,".repeat(1000) + "\n";
	}
```

There is a comma at the end of this string that is unnecessary but it won't cause us an hassle so we won't remove it either.

Finally, our newGame() method writes the state of the game in a file and we already have a method for writing to that file in place. With all helper methods implemented, here what our newGame() method looks like:

```
	@Command(name = "new")
	public void newGame() {
		//setup a random layout of mines in a grid of 1000 tiles
		List<Integer> mines = setUpMines();
		//put the mines in a grid so that we can count the number of mines next to each tile
		String[][] grid = setUpGrid(mines);
		//count the number of mines next to each tile
		setUpMineCounts(grid);
		//put the grid into one line as it is supposed to be when stored in our state file
		String oneLine = putInOneLine(grid);
		try {
			//initiate in one line the state as user sees it when looking at the grid
			String userPerspective = initUserPerspective();
			//write the game state in the file
			writeLineInFile(oneLine, false);
			writeLineInFile(userPerspective, true);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
```

And that completes our implementation of the newGame() method, allowing us to start new minesweeper games.

We now need to implement our show and opentile commands.

## Before we move on to do that...

If you find any value in this tutorial but would rather develop something more practical than a command-line minesweeper game then you may find this small book [here](benjalin.gumroad.com/l/fapnd) where I use picocli to develop a password manager. It starts as a small command line password manager that allows a user to add, see, and delete stored passwords and ends by including encryption of passwords and the writing of passwords to the clipboard when a user wants to use one of their stored passwords. Also, it overwrites the contents of the clipboard soon after a password has been written to it to prevent accidental discovery of passwords by other users (or pasting them unintentionally elsewhere by the same user that owns the passwords).

## Implementing the show command

Just as we did for the method that actually starts a new game, let us fill our show() method with comments that explain what it needs to do before we proceed to implement any necessary helper methods. Here is show() method with those comments:

```
	@Command(name = "show")
	public void show() {
		//get user perspective from the file that contains the game state
		//put the user perspective into a grid
		//print that grid
	}
```

We already have a method that retrieves the user perspective from the file that contains the game state.

We now need to have a method that takes the user perspective state as a string and turns it into a two-dimensional array. Here is the implementation of that method:

```
	private String[][] getGridFromOneLineString(String game) {
		String[] tiles = game.split(",");
		String[][] grid = new String[20][50];
		for(int i = 0; i < 20; i++) {
			for(int j = 0; j < 50; j++) {
				int k = 50*i + j;
				grid[i][j] = tiles[k];
			}
		}
		return grid;
	}
```

So, the method takes the game's user perspective as a string consisting of tile contents separated by commas and splits it around commas. With tiles in a one dimensional array, a two-dimensional array grid is built in the two for-loops, and that grid is returned.

Finally, we want to print the grid as the user sees it in the console. Here is a method to do just that:

```
	private void printGrid(String[][] grid) {
		System.out.println("        0         1         2         3         4");
		System.out.println("   01234567890123456789012345678901234567890123456789");
		int i = 0;
		for(String[] row : grid) {
			if(i < 10) {
				System.out.print(" " + i + " ");
			}
			else {
				System.out.print(i + " ");
			}
			i++;
			for(String column : row) {
				System.out.print(column);
			}
			System.out.println();
		}
	}
```

And, here is the explanation for this last method: we first want to print something like a header to the grid that our game is. It will come in handy when we want to specify what column tile we want fliped. So, the first two System.out.println()s give us visual clues as to where a column between 0 and 49 stand. Next, inside our for loop, we have an if(i < 10) which makes sure that one-digit numbered rows are preceded by a two-character number, so that they align well with the other rows whose number is two digits. To visualize, instead of this:

```
row 9 HHHHH
ROW 10 HHHHH
```

we would like to see this:

```
row  9 HHHH
ROW 10 HHHH
```

The inner for-loop is just printing the columns in the current row. After the for-loop, we have a System.out.println() that makes sure that the next row in the outter loop is printed in the next line. With our printGrid() method in place, we have everything we need to have a working implementation of our show() method. Here is our show() method fully implemented:

```
	@Command(name = "show")
	public void show() {
		try {
			//get user perspective from the file that contains the game state
			String userPerspective = getUserPesrpectiveFromFile();
			//put the user perspective into a grid
			String[][] grid = getGridFromOneLineString(userPerspective);
			//print that grid
			printGrid(grid);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
```


Now that we can start a new game and chose to show its state any time we want, we are one step removed from being able to play Minesweeper in a non-interactive command line application. All we need is a method to open tiles that we would like to open.

## Implementing the opentile command

When we want to open a tile we need to be able to specify what row, what column the tile is on. That means that the current state of our opentile() method needs to be modified to allow for specifying the row and column of the tile we want flipped open. Here is the actual method signature for our opentile() method. Please replace the earlier version of it with this newer one:

```
	@Command(name = "opentile")
	public void opentile(@Parameters(index = "0") int row, @Parameters(index = "1") int column) {
		
	}
```

So, at this point we just declared the two parameters that our opentile() method needs to receive. Let us again, as we did earlier, fill our opetile() method with comments that specify what steps it will take in the course of doing its job. Here is opentile() with those comments:

```
	@Command(name = "opentile")
	public void opentile(@Parameters(index = "0") int row, @Parameters(index = "1") int column) {
		//read game state
		//read user perspective state
		//put game state on a grid
		//put user perspective on another grid
		//read the content of the tile specified by row and column from the grid, not user perspective
		//check if game is over. if yes, let user know and stop further work in this method
		//disclose the content of the tile specified by row and tile by puting it in user perspective grid
		//check if that tile's content is an empty space
		    //if yes, then we would like to flip open the adjacent tiles that contain either a number or a space
		    //for all newly opened tiles, we would like to update user perspective to show them open and match the content in the actual grid that knows where the mines are
		//now that our user perspective has changed, we would like to rebuild the one-line representation of it before saving the state
		//write the game state (as it overwrites the contents of the file that contains it allowing us to predictably put user perspective in the second line in that file)
		//write user perspective to the file that contains the game state
		
		//check if game is solved, and if yes, print a message to indicate that
		//print the user perspective grid
	}
```

This method is somewhat longer than the other two. However, it consists of a greater number of steps, each of which is just as simple as the steps in the other two methods are. In addition, we already have most of the helper methods necessary for the implementation of our opentile() method. We only lack three methods: one to check if game is over, meaning that a tile that covers a mine has been fliped, one to check if game is solved, meaning that all tiles except those covering a mine have been flipped, and one to find empty spaces next to a number or an empty space. This last one is slightly more involved, so we will leave it for the end.

Let us implement a method to check if a game is over. Here is the code for such a method:

```
	private boolean isGameOver(String userPerspective) {
		return userPerspective.contains("M");
	}
```

Basically, a game is over soon as tile that covers a mine has been flipped open. At the level of code, that means that our user perspective shows an M.

Let us now implement a method to check if a game is solved. Here is the code for such a method:

```
	private boolean isSolved(String[][] grid, String[][] userPerspective) {
		for(int row = 0; row < userPerspective.length; row++) {
			for(int column = 0; column < userPerspective[0].length; column++) {
				if("H".equals(userPerspective[row][column]) && !"M".equals(grid[row][column])) {
					return false;
				}
			}
		}
		return true;
	}
```

So, basically, a game is not solved until there is at least one tile that does not cover a mine and that has not been flipped yet in our user perspective. To check for that, we compare every tile in the user perspective grid to the corresponding tile in the grid that knows where the mines are; if there is an H tile in the user perspective grid that covers a number or an empty space in the corresponding tile in the grid that knows where the mines are, then the game has not been solved yet.

Finally, we may begin the implementation of a method that flips all tiles that cover an empty space or a number and that are immediately next to an open tile that covers an empty space. Here is the code for such a method:

```
	private Set<String> findAllAdjecantEmptySpaces(String[][] grid, List<String> candidates, Set<String> result, Set<String> visited) {
		if(candidates.isEmpty()) {
			return result;
		}
		String c = candidates.remove(0);
		visited.add(c);
		String[] coordinates = c.split("x");
		int row = Integer.parseInt(coordinates[0]);
		int column = Integer.parseInt(coordinates[1]);
		if(!" ".equals(grid[row][column])) {
			return findAllAdjecantEmptySpaces(grid, candidates, result, visited);
		}
		result.add(c);
//		north
		if(row > 0) {
			result.add((row - 1) + "x" + column);
			if(" ".equals(grid[row - 1][column])) {
				candidates.add((row - 1) + "x" + column);
			}
		}
//		east
		if(column < 49) {
			result.add(row + "x" + (column + 1));
			if(" ".equals(grid[row][column + 1])) {
				candidates.add(row + "x" + (column + 1));
			}
		}
//		south
		if(row < 19) {
			result.add((row + 1) + "x" + column);
			if(" ".equals(grid[row + 1][column])) {
				candidates.add((row + 1) + "x" + column);
			}
		}
//		west
		if(column > 0) {
			result.add(row + "x" + (column - 1));
			if(" ".equals(grid[row][column - 1])) {
				candidates.add(row + "x" + (column - 1));
			}
		}
//		northeast
		if(row > 0 && column < 49) {
			result.add((row - 1) + "x" + (column + 1));
			if(" ".equals(grid[row - 1][column + 1])) {
				candidates.add((row - 1) + "x" + (column + 1));
			}
		}
//		southeast
		if(row < 19 && column < 49) {
			result.add((row + 1) + "x" + (column + 1));
			if(" ".equals(grid[row + 1][column + 1])) {
				candidates.add((row + 1) + "x" + (column + 1));
			}
		}
//		southwest
		if(row < 19 && column > 0) {
			result.add((row + 1) + "x" + (column - 1));
			if(" ".equals(grid[row + 1][column - 1])) {
				candidates.add((row + 1) + "x" + (column - 1));
			}
		}
//		northwest
		if(row > 0 && column > 0) {
			result.add((row - 1) + "x" + (column - 1));
			if(" ".equals(grid[row - 1][column - 1])) {
				candidates.add((row - 1) + "x" + (column - 1));
			}
		}
		List<String> nextCandidates = candidates.stream().distinct().collect(Collectors.toList());
		nextCandidates.removeAll(visited);
		return findAllAdjecantEmptySpaces(grid, nextCandidates, result, visited);
	}
```

Here is an explanation for what the method does. First, I used a recursive implementation for this method. What that means is that the method calls itself, repeatedly, until some condition is met. In this case, that condition is that there are no more tiles to check whether they cover a number or an empty space. That is the line that says ```if(candidates.isEmpty())```.

If candidates list is not empty, then we proceed to check all neighbors of the first candidate in the list of candidates. To do that, we first retrieve it from the candidates. That is the line that contains:

```
String candidate = candidates.get(0);
```

Next, we put this candidate in the set of visited candidates. That is, the line ```visited.add(c);```.

Since I opted to model candidates as Strings of the shape row_numberXcolumn_number, we need to manipulate those strings to determine what row and what column the candidate is on. Once we determined the row and column of candidate, we check to see if it is an empty space and if yes, we recursively call findAllAdjecantEmpty() method for this candidate tile. If not, then we can assume safely that the candidate is a tile that covers a number. We can make this assumption safely because we know with certainty that when we counted mines next to a tile, those that covered an empty space were next to now mines. Hence, we put the candidate in the result set.

Next, we have a series of if-checks. The outter if-checks are intended to make sure that we do not try to read outside of the grid, as we would in case we tried to read row numbered -1 or column 20. And the inner if-checks, they check if a neighboring tile is an empty space and if yes, that neighboring tile is a tile whose neighbors need to be checked also. And that is all as far as the steps in this method go.

However, a side note is that if a tile A is the neighbor of a tile B, then the tile B is also a neighbor of the tile A. So, while checking for neighbors of A, we will be led to checking the tile B but then when checking tile B we will be led back to checking tile A, effectively given us infinite recursion. To prevent that, the method keeps track of what tiles have been visited and makes use of that to remove visited candidates from the next call to the findAllAdjecantEmptySpaces() method.

The next subtlety may be the choice of using List to keep candidates and using Set for other data, namely result and visited. I used List for candidates because Set does not have a get() method. And I used Set for visited because sets do not keep more than one instance of an element, and as such, they are more efficient whn repeatedly adding to them. For example, calling visited.add("1x1") multiple times will still only contain a single instance of "1x".

Anyways, now we have all we need to implement our opentile() method. Here is its full implementation, along with the comments we initially put inside it:

```
	@Command(name = "opentile")
	public void opentile(@Parameters(index = "0") int row, @Parameters(index = "1") int column) {
		try {
			//read game state
			String game = getGameFromFile();
			//read user perspective state
			String userPerspective = getUserPesrpectiveFromFile();
			//put game state on a grid
			String[][] grid = getGridFromOneLineString(game);
			//put user perspective on another grid
			String[][] gridUserPerspective = getGridFromOneLineString(userPerspective);
			//read the content of the tile specified by row and column from the grid, not user perspective
			String tileContent = grid[row][column];
			//check if game is over. if yes, let user know and stop further work in this method
			if(isGameOver(userPerspective)) {
				System.out.println("kabooom, game ended");
				return;
			}
			//disclose the content of the tile specified by row and tile by puting it in user perspective grid
			gridUserPerspective[row][column] = tileContent;
			//check if that tile's content is an empty space
			if(" ".equals(tileContent)) {
				List<String> coords = new ArrayList<>();
				//if yes, then we would like to flip open the adjecant tiles that contain either a number or a space
				coords.add(row+"x"+column);
				Set<String> emptySpaces = findAllAdjecantEmptySpaces(grid, coords, new HashSet<>(), new HashSet<>());
				//for all newly opened tiles, we would like to update user perspective to show them open and match the content in the actual grid that knows where the mines are
				for(String es : emptySpaces) {
					String[] esCoords = es.split("x");
					int esRow = Integer.parseInt(esCoords[0]);
					int esColumn = Integer.parseInt(esCoords[1]);
					gridUserPerspective[esRow][esColumn] = grid[esRow][esColumn];
				}
			
			}
			//now that our user perspective has changed, we would like to rebuild the one-line representation of it before saving the state
			String userPerspectiveLine = putInOneLine(gridUserPerspective);
			//write the game state (as it overwrites the contents of the file that contains it allowing us to predictably put user perspective in the second line in that file)
			writeLineInFile(game, false);
			//write user perspective to the file that contains the game state
			writeLineInFile(userPerspectiveLine, true);
			//check if game is solved, and if yes, print a message to indicate that
			if(isSolved(grid, gridUserPerspective)) {
				System.out.println("CONGRATULATIONS, YOU FOUND ALL THE MINES!");
			}
			//print the user perspective grid
			printGrid(gridUserPerspective);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
```

## Trying the game

We can definitely use the main method and run our application in Eclipse to try it, but that would require us to repeatedly modify our main method and that is too tedious. For a less tedious way to try our application, let us first build it.

To be able to build it, we need first modify our pom.xml file. There must already be a ```<build>``` section in your pom.xml file. Replace it with this content:

```
	<build>
		<plugins>
			<!-- any other plugins -->
			<plugin>
				<artifactId>maven-assembly-plugin</artifactId>
				<executions>
					<execution>
						<phase>package</phase>
						<goals>
							<goal>single</goal>
						</goals>
					</execution>
				</executions>
				<configuration>
					<archive>
						<manifest>
							<addClasspath>true</addClasspath>
							<mainClass>com.minesweeper.App</mainClass>
						</manifest>
					</archive>
					<descriptorRefs>
						<descriptorRef>jar-with-dependencies</descriptorRef>
					</descriptorRefs>
				</configuration>
			</plugin>
		</plugins>
	</build>
```

The only assumption in this content that may not hold for your code is this line:

```
<mainClass>com.minesweeper.App</mainClass>

```

Make sure that the package and file name or correct for your code. If that is so and you have the maven build tool installed in your system, you may navigate in a terminal to the root directory of your project and run:

```
mvn clean package
```

This command will generate a couple of jar files in your target directory inside the root directory of your project. One of those jar files will contain 'with-dependencies' in its name. Let us say that the name of the file is minesweeper-with-dependencies.jar. Then, assuming that you are still in a terminal and your current directory is the root of your project, then you may run any of the following commands successfully:

To start a new game:

```
java -jar target/minesweeper-with-dependencies.jar new
```

To show the state of the game:

```
java -jar target/minesweeper-with-dependencies.jar show
```

To open a tile of your chosing, saying row 0, tile 19:

```
java -jar target/minesweeper-with-dependencies.jar opentile 0 19
```

And that is all. I hope you had as much fun following with this tutorial as I had writing it. I hope you liked it and, again, if you would like to build another more practical command line application with picocli you may head to my gumroad [here](benjalin.gumroad.com/l/fapnd) where I have made available a small pdf with a guide on how to write a complete command line password manager at a small price of $3.8. To get an idea of what you may find here, we start by implementing a simple command line password manager that simply stores passwords in a local database and prints them in a terminal when prompted. IN addition to that, it allows you to delete the passwords. At the end, I show you how to include encryption of passwords and write them in your clipboard temporarily for when you need to use them. But in between, I show you how to turn the command line password manager into a web application rapidly, and then build another command line interface to that web application for the purpose of exercise. In other words, my intention was to provide the interested with a guided experience writing Java applications while also building a useful application.
